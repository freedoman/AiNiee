# 段落智能合并功能说明

## 功能概述

在 `DocxAccessor.py` 中新增了 `_merge_incomplete_paragraphs()` 方法,用于自动检测并合并原始DOCX文件中被错误分割的段落。

## 问题背景

原始DOCX文件中存在段落分割错误,例如:
- `para_index=66`: `"2. DOTS-Plus 策略  DOTS 策略虽然可以治"`
- `para_index=67`: `"愈大部分的结核患者,但是短程化疗方案却..."`

这种分割导致LLM翻译时误解上下文,将 `2.` 识别为引用编号而非列表编号。

## 解决方案

### 检测规则

自动检测以下**不完整段落特征**:

1. **不完整动词短语**: `可以治`、`能够做`、`将进行` 等
2. **连接词结尾**: `但`、`而`、`且`、`或`、`因此` 等  
3. **结构助词**: `的`、`地`、`得`
4. **动态助词**: `了`、`着`、`过`

### 保护规则

**不合并**以下情况(避免错误合并):

1. **数字编号开头**: `1.`、`2.`、`(1)` 等
2. **中文编号**: `一、`、`二、`
3. **英文标题**: 大写字母开头
4. **章节标记**: `第`、`章`、`节`

### 实现位置

```python
# ModuleFolders/FileAccessor/DocxAccessor.py, line ~365

def read_paragraphs(...):
    # ... 读取段落逻辑 ...
    
    # 智能合并不完整段落
    if not skip_simplify:  # 只在 Reader 读取时执行
        paragraphs = self._merge_incomplete_paragraphs(paragraphs)
    
    return paragraphs
```

## 测试结果

### 原问题案例

**修复前**:
- 段落1: `"2. DOTS-Plus 策略  DOTS 策略虽然可以治"`
- 段落2: `"愈大部分的结核患者,但是短程化疗方案..."`
- 翻译: `"[2] Стратегия DOTS-Plus"` ❌ (错误:识别为引用)

**修复后**:
- 合并段落: `"2. DOTS-Plus 策略  DOTS 策略虽然可以治愈大部分的结核患者,但是短程化疗方案..."`
- 翻译: `"2. Стратегия DOTS-Plus"` ✅ (正确:保持列表编号)

### 统计数据

- 缓存文件中以数字编号开头的段落: **16个**
- 检测到的异常短段落(<80字符): **5个**
- 确认需要合并的段落对: **2个** (约12.5%)

## 使用方法

功能已自动集成,无需额外配置:

1. 重新运行翻译项目
2. 系统自动检测并合并不完整段落
3. 提交到LLM的文本已是完整句子

## 注意事项

1. **只在Reader阶段生效**: Writer读取缓存时(`skip_simplify=True`)不执行合并
2. **保留边界标记**: 合并后保持原有的`<RUNBND>`标记结构
3. **非破坏性**: 不修改原始DOCX文件,仅在内存中合并

## 未来改进

如果遇到其他类型的分割问题,可以扩展检测规则:

```python
# 在 _merge_incomplete_paragraphs() 中添加更多模式
incomplete_patterns = [
    r'新的不完整模式$',  # 新规则
]
```

## 相关文件

- 实现: `ModuleFolders/FileAccessor/DocxAccessor.py` (line 368-435)
- 测试: `test_merge.py`
- 分析脚本: `check_splits.py`
